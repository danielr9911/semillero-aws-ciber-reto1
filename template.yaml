AWSTemplateFormatVersion: '2010-09-09'
Description: 'Sistema de Reservas para Hotel - Infraestructura AWS'

Parameters:
  BucketName:
    Type: String
    Description: 'Nombre del bucket S3 para almacenar archivos estáticos y documentos'
    Default: 'hotel-reservations-NOMBRE-SEMILLERO'
  
  AdminEmail:
    Type: String
    Description: 'Dirección de email del administrador para recibir notificaciones'
    Default: 'admin@example.com'
  
  EC2InstanceType:
    Type: String
    Description: 'Tipo de instancia EC2'
    Default: 't2.micro'
    AllowedValues:
      - 't2.micro'
      - 't2.small'
      - 't2.medium'

Resources:
  # S3 Bucket para archivos estáticos y documentos
  HotelReservationsBucket:
    Type: 'AWS::S3::Bucket'
    Properties:
      BucketName: !Ref BucketName
      AccessControl: Private
      CorsConfiguration:
        CorsRules:
          - AllowedHeaders:
              - '*'
            AllowedMethods:
              - GET
              - PUT
              - POST
              - DELETE
            AllowedOrigins:
              - '*'
            MaxAge: 3000
      
  # Política de bucket para hacer públicos los archivos estáticos
  HotelReservationsBucketPolicy:
    Type: 'AWS::S3::BucketPolicy'
    Properties:
      Bucket: !Ref HotelReservationsBucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: PublicReadForGetBucketObjects
            Effect: Allow
            Principal: '*'
            Action: 's3:GetObject'
            Resource: !Sub '${HotelReservationsBucket.Arn}/statics/*'
  
  # Tabla DynamoDB para almacenar reservas
  HotelReservationsTable:
    Type: 'AWS::DynamoDB::Table'
    Properties:
      TableName: HotelReservations
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: ReservationID
          AttributeType: S
      KeySchema:
        - AttributeName: ReservationID
          KeyType: HASH
      StreamSpecification:
        StreamViewType: NEW_AND_OLD_IMAGES
  
  # Tema SNS para notificaciones de conflictos
  ReservationConflictsTopic:
    Type: 'AWS::SNS::Topic'
    Properties:
      TopicName: HotelReservationsConflicts
      DisplayName: 'Conflictos de Reservas de Hotel'
  
  # Suscripción al tema SNS para el administrador
  AdminSubscription:
    Type: 'AWS::SNS::Subscription'
    Properties:
      TopicArn: !Ref ReservationConflictsTopic
      Protocol: email
      Endpoint: !Ref AdminEmail
  
  # Rol IAM para la función Lambda
  LambdaExecutionRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
      Policies:
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'dynamodb:GetItem'
                  - 'dynamodb:PutItem'
                  - 'dynamodb:UpdateItem'
                  - 'dynamodb:DeleteItem'
                  - 'dynamodb:Scan'
                  - 'dynamodb:Query'
                Resource: !GetAtt HotelReservationsTable.Arn
        - PolicyName: SNSPublish
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'sns:Publish'
                Resource: !Ref ReservationConflictsTopic
  
  # Función Lambda para validar reservas
  ReservationValidatorFunction:
    Type: 'AWS::Lambda::Function'
    Properties:
      FunctionName: HotelReservationValidator
      Runtime: python3.9
      Handler: lambda_function.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      MemorySize: 128
      Environment:
        Variables:
          SNS_TOPIC_ARN: !Ref ReservationConflictsTopic
          DYNAMODB_TABLE: !Ref HotelReservationsTable
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          from datetime import datetime
          from decimal import Decimal
          
          # Inicializar clientes de AWS
          dynamodb = boto3.resource('dynamodb')
          sns = boto3.client('sns')
          
          # Obtener el ARN del tema SNS desde las variables de entorno
          SNS_TOPIC_ARN = os.environ.get('SNS_TOPIC_ARN')
          
          # Referencia a la tabla DynamoDB
          table = dynamodb.Table('HotelReservations')
          
          class DecimalEncoder(json.JSONEncoder):
              """Clase auxiliar para manejar el tipo Decimal de DynamoDB en la serialización JSON"""
              def default(self, o):
                  if isinstance(o, Decimal):
                      return float(o)
                  return super(DecimalEncoder, self).default(o)
          
          def check_reservation_conflicts(room_number, check_in_date, check_out_date, current_reservation_id):
              """
              Verifica si hay conflictos con otras reservas para la misma habitación y fechas superpuestas.
              """
              # Convertir fechas de string a objetos datetime para comparación
              check_in = datetime.strptime(check_in_date, '%Y-%m-%d')
              check_out = datetime.strptime(check_out_date, '%Y-%m-%d')
              
              # Escanear la tabla para buscar todas las reservas para la habitación especificada
              response = table.scan(
                  FilterExpression="RoomNumber = :room AND ReservationID <> :rid AND #status <> :canceled",
                  ExpressionAttributeValues={
                      ':room': room_number,
                      ':rid': current_reservation_id,
                      ':canceled': 'Cancelada'
                  },
                  ExpressionAttributeNames={
                      '#status': 'Status'
                  }
              )
              
              conflicts = []
              
              # Verificar cada reserva existente para detectar solapamientos de fechas
              for item in response.get('Items', []):
                  existing_check_in = datetime.strptime(item['CheckInDate'], '%Y-%m-%d')
                  existing_check_out = datetime.strptime(item['CheckOutDate'], '%Y-%m-%d')
                  
                  # Verificar si hay solapamiento de fechas
                  if check_in < existing_check_out and check_out > existing_check_in:
                      conflicts.append(item)
              
              return conflicts
          
          def send_conflict_notification(reservation, conflicts):
              """
              Envía una notificación SNS sobre un conflicto de reservas
              """
              if not SNS_TOPIC_ARN:
                  print("ERROR: No se ha configurado la variable de entorno SNS_TOPIC_ARN")
                  return
              
              # Crear el mensaje
              subject = f"¡ALERTA! Conflicto de reservas para la habitación {reservation['RoomNumber']}"
              
              message_body = f"""
              Se ha detectado un conflicto de reservas en el sistema del Hotel Cloud Suites.
              
              Detalles de la nueva reserva:
              - ID: {reservation['ReservationID']}
              - Habitación: {reservation['RoomNumber']}
              - Huésped: {reservation['GuestName']}
              - Fecha de entrada: {reservation['CheckInDate']}
              - Fecha de salida: {reservation['CheckOutDate']}
              - Email: {reservation['ContactEmail']}
              
              Esta reserva tiene conflicto con las siguientes reservas existentes:
              """
              
              for conflict in conflicts:
                  message_body += f"""
              * Reserva ID: {conflict['ReservationID']}
                - Huésped: {conflict['GuestName']}
                - Fecha de entrada: {conflict['CheckInDate']}
                - Fecha de salida: {conflict['CheckOutDate']}
                - Email: {conflict['ContactEmail']}
              """
              
              # Enviar la notificación
              try:
                  response = sns.publish(
                      TopicArn=SNS_TOPIC_ARN,
                      Subject=subject,
                      Message=message_body
                  )
                  print(f"Notificación enviada: {response['MessageId']}")
              except Exception as e:
                  print(f"Error al enviar la notificación: {str(e)}")
          
          def update_reservation_status(reservation_id, new_status):
              """
              Actualiza el estado de una reserva en DynamoDB
              """
              try:
                  table.update_item(
                      Key={'ReservationID': reservation_id},
                      UpdateExpression="set #status = :s",
                      ExpressionAttributeNames={'#status': 'Status'},
                      ExpressionAttributeValues={':s': new_status}
                  )
                  print(f"Reserva {reservation_id} actualizada a estado: {new_status}")
              except Exception as e:
                  print(f"Error al actualizar la reserva: {str(e)}")
          
          def process_reservation_record(record):
              """
              Procesa un registro individual de reserva
              """
              # Verificar si es un evento INSERT o MODIFY
              if record.get('eventName') in ['INSERT', 'MODIFY']:
                  # Obtener los datos de la nueva reserva
                  if 'dynamodb' in record and 'NewImage' in record['dynamodb']:
                      # Convertir de formato DynamoDB a formato Python
                      new_image = record['dynamodb']['NewImage']
                      reservation = {}
                      for key, value in new_image.items():
                          # Obtener el valor según el tipo
                          if 'S' in value:
                              reservation[key] = value['S']
                          elif 'N' in value:
                              reservation[key] = Decimal(value['N'])
                          elif 'BOOL' in value:
                              reservation[key] = value['BOOL']
                          elif 'M' in value:
                              reservation[key] = value['M']
                          elif 'L' in value:
                              reservation[key] = value['L']
                      
                      # Si es un evento válido con datos de reserva
                      if reservation and 'ReservationID' in reservation:
                          print(f"Procesando reserva: {reservation['ReservationID']}")
                          
                          # Verificar si hay conflictos
                          conflicts = check_reservation_conflicts(
                              reservation['RoomNumber'],
                              reservation['CheckInDate'],
                              reservation['CheckOutDate'],
                              reservation['ReservationID']
                          )
                          
                          if conflicts:
                              print(f"Se encontraron {len(conflicts)} conflictos")
                              # Marcar la reserva como 'Conflicto' en DynamoDB
                              update_reservation_status(reservation['ReservationID'], 'Conflicto')
                              # Enviar notificación sobre el conflicto
                              send_conflict_notification(reservation, conflicts)
                          else:
                              print("No se encontraron conflictos")
                              # Si es una nueva reserva o pendiente, marcarla como confirmada
                              if record.get('eventName') == 'INSERT' or reservation.get('Status') == 'Pendiente':
                                  update_reservation_status(reservation['ReservationID'], 'Confirmada')
          
          def lambda_handler(event, context):
              """
              Función principal que se ejecuta cuando la Lambda es invocada
              """
              print("Evento recibido:", json.dumps(event, cls=DecimalEncoder))
              
              try:
                  # Verificar si es un evento de EventBridge
                  if 'detail-type' in event and event.get('source') == 'aws.dynamodb':
                      # Procesar evento de EventBridge
                      detail = event.get('detail', {})
                      if detail.get('eventName') in ['INSERT', 'MODIFY']:
                          # Simular formato de registro para process_reservation_record
                          record = {
                              'eventName': detail.get('eventName'),
                              'dynamodb': {
                                  'NewImage': detail.get('dynamodb', {}).get('NewImage', {})
                              }
                          }
                          process_reservation_record(record)
                      return {
                          'statusCode': 200,
                          'body': 'Procesamiento de evento EventBridge completado'
                      }
                      
                  # Procesar eventos de DynamoDB Streams
                  for record in event.get('Records', []):
                      process_reservation_record(record)
                  
                  return {
                      'statusCode': 200,
                      'body': 'Procesamiento completado con éxito'
                  }
              
              except Exception as e:
                  print(f"Error en el procesamiento: {str(e)}")
                  return {
                      'statusCode': 500,
                      'body': f'Error en el procesamiento: {str(e)}'
                  }
  
  # Regla de EventBridge para detectar cambios en DynamoDB
  DynamoDBEventRule:
    Type: 'AWS::Events::Rule'
    Properties:
      Name: HotelReservationsDynamoDBEvents
      Description: 'Detecta cambios en la tabla DynamoDB de reservas'
      EventPattern:
        source:
          - aws.dynamodb
        detail-type:
          - 'AWS API Call via CloudTrail'
        detail:
          eventSource:
            - dynamodb.amazonaws.com
          eventName:
            - PutItem
            - UpdateItem
          requestParameters:
            tableName:
              - HotelReservations
      State: ENABLED
      Targets:
        - Arn: !GetAtt ReservationValidatorFunction.Arn
          Id: ProcessReservation
  
  # Permiso para que EventBridge invoque la función Lambda
  LambdaPermissionForEventBridge:
    Type: 'AWS::Lambda::Permission'
    Properties:
      FunctionName: !GetAtt ReservationValidatorFunction.Arn
      Action: 'lambda:InvokeFunction'
      Principal: events.amazonaws.com
      SourceArn: !GetAtt DynamoDBEventRule.Arn
  
  # Rol para instancia EC2
  EC2InstanceRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/AmazonS3FullAccess'
        - 'arn:aws:iam::aws:policy/AmazonDynamoDBFullAccess'
  
  # Perfil de instancia para EC2
  EC2InstanceProfile:
    Type: 'AWS::IAM::InstanceProfile'
    Properties:
      Roles:
        - !Ref EC2InstanceRole
  
  # Grupo de seguridad para EC2
  WebServerSecurityGroup:
    Type: 'AWS::EC2::SecurityGroup'
    Properties:
      GroupDescription: 'Allows HTTP/HTTPS and SSH access'
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 22
          ToPort: 22
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 5000
          ToPort: 5000
          CidrIp: 0.0.0.0/0
  
  # Instancia EC2 para el servidor web
  WebServerInstance:
    Type: 'AWS::EC2::Instance'
    Properties:
      InstanceType: !Ref EC2InstanceType
      ImageId: ami-0a6b2839d44d781b2  # Amazon Linux 2 AMI (ajustar según la región)
      SecurityGroupIds:
        - !Ref WebServerSecurityGroup
      IamInstanceProfile: !Ref EC2InstanceProfile
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash
          yum update -y
          yum install -y python3 python3-pip git
          pip3 install flask boto3 werkzeug
          
          # Crear dirección para la aplicación
          mkdir -p /opt/hotel-app
          
          # Clonar repositorio o crear archivos desde cero
          cat > /opt/hotel-app/app.py << 'EOL'
          from flask import Flask, render_template, request, redirect, url_for, flash, jsonify
          import boto3
          import uuid
          import os
          from datetime import datetime
          from werkzeug.utils import secure_filename
          import json

          app = Flask(__name__)
          app.secret_key = 'cloud_suites_hotel_secure_key'

          # Configuración de AWS
          S3_BUCKET_NAME = '${BucketName}'
          REGION_NAME = '${AWS::Region}'

          # Inicializar clientes de AWS
          s3 = boto3.client('s3', region_name=REGION_NAME)
          dynamodb = boto3.resource('dynamodb', region_name=REGION_NAME)
          table = dynamodb.Table('HotelReservations')

          # Configuración para la carga de archivos
          ALLOWED_EXTENSIONS = {'pdf', 'png', 'jpg', 'jpeg'}
          MAX_CONTENT_LENGTH = 5 * 1024 * 1024  # 5MB max

          def allowed_file(filename):
              """Verifica si la extensión del archivo es válida"""
              return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

          @app.route('/')
          def index():
              """Página principal del sistema"""
              return render_template('index.html')

          @app.route('/reservations')
          def list_reservations():
              """Lista todas las reservas existentes"""
              try:
                  # Escanear la tabla para obtener todas las reservas
                  response = table.scan()
                  reservations = response.get('Items', [])
                  
                  # Ordenar por fecha de check-in
                  reservations.sort(key=lambda x: x.get('CheckInDate', ''))
                  
                  return render_template('reservations.html', reservations=reservations)
              except Exception as e:
                  flash(f"Error al obtener las reservas: {str(e)}", 'danger')
                  return render_template('reservations.html', reservations=[])

          @app.route('/reservation/new', methods=['GET', 'POST'])
          def new_reservation():
              """Crear una nueva reserva"""
              if request.method == 'POST':
                  try:
                      # Recoger datos del formulario
                      guest_name = request.form.get('guest_name')
                      room_number = request.form.get('room_number')
                      check_in_date = request.form.get('check_in_date')
                      check_out_date = request.form.get('check_out_date')
                      contact_email = request.form.get('contact_email')
                      
                      # Validación básica
                      if not all([guest_name, room_number, check_in_date, check_out_date, contact_email]):
                          flash('Todos los campos son obligatorios', 'danger')
                          return redirect(url_for('new_reservation'))
                          
                      # Validar fechas
                      try:
                          check_in = datetime.strptime(check_in_date, '%Y-%m-%d')
                          check_out = datetime.strptime(check_out_date, '%Y-%m-%d')
                          if check_in >= check_out:
                              flash('La fecha de salida debe ser posterior a la fecha de entrada', 'danger')
                              return redirect(url_for('new_reservation'))
                      except ValueError:
                          flash('Formato de fecha inválido', 'danger')
                          return redirect(url_for('new_reservation'))
                      
                      # Generar ID único para la reserva
                      reservation_id = str(uuid.uuid4())
                      document_id = None
                      
                      # Gestionar carga de documento de identidad
                      if 'identity_document' in request.files:
                          file = request.files['identity_document']
                          if file and file.filename and allowed_file(file.filename):
                              # Asegurar nombre de archivo y determinar ruta
                              filename = secure_filename(file.filename)
                              file_extension = filename.rsplit('.', 1)[1].lower()
                              document_id = f"{reservation_id}.{file_extension}"
                              s3_path = f"documents/{document_id}"
                              
                              # Subir archivo a S3
                              s3.upload_fileobj(
                                  file,
                                  S3_BUCKET_NAME,
                                  s3_path,
                                  ExtraArgs={'ContentType': f'application/{file_extension}'}
                              )
                      
                      # Crear registro en DynamoDB
                      reservation_item = {
                          'ReservationID': reservation_id,
                          'RoomNumber': room_number,
                          'GuestName': guest_name,
                          'CheckInDate': check_in_date,
                          'CheckOutDate': check_out_date,
                          'ContactEmail': contact_email,
                          'Status': 'Pendiente',
                          'CreatedAt': datetime.now().isoformat(),
                          'DocumentID': document_id if document_id else 'Sin documento'
                      }
                      
                      table.put_item(Item=reservation_item)
                      
                      flash('Reserva creada exitosamente. En breve recibirá un correo de confirmación.', 'success')
                      return redirect(url_for('list_reservations'))
                      
                  except Exception as e:
                      flash(f"Error al crear la reserva: {str(e)}", 'danger')
                      return redirect(url_for('new_reservation'))
              
              # Si es GET, mostrar el formulario
              return render_template('new_reservation.html')

          @app.route('/reservation/<reservation_id>')
          def view_reservation(reservation_id):
              """Ver detalles de una reserva específica"""
              try:
                  # Obtener la reserva por ID
                  response = table.get_item(Key={'ReservationID': reservation_id})
                  
                  if 'Item' in response:
                      reservation = response['Item']
                      return render_template('view_reservation.html', reservation=reservation, S3_BUCKET_NAME=S3_BUCKET_NAME)
                  else:
                      flash('Reserva no encontrada', 'warning')
                      return redirect(url_for('list_reservations'))
                      
              except Exception as e:
                  flash(f"Error al obtener la reserva: {str(e)}", 'danger')
                  return redirect(url_for('list_reservations'))

          # ... [resto del código app.py] ...

          if __name__ == '__main__':
              # Crear carpeta temporal para archivos subidos si no existe
              os.makedirs('tmp', exist_ok=True)
              # Ejecutar la aplicación en modo debug
              app.run(host='0.0.0.0', port=5000, debug=True)
          EOL
          
          # Crear directorios para templates y archivos estáticos
          mkdir -p /opt/hotel-app/templates
          mkdir -p /opt/hotel-app/static
          
          # Crear un servicio systemd para ejecutar la aplicación
          cat > /etc/systemd/system/hotel-app.service << EOL
          [Unit]
          Description=Hotel Reservation Application
          After=network.target
          
          [Service]
          User=root
          WorkingDirectory=/opt/hotel-app
          ExecStart=/usr/bin/python3 app.py
          Restart=always
          
          [Install]
          WantedBy=multi-user.target
          EOL
          
          # Habilitar e iniciar el servicio
          systemctl enable hotel-app
          systemctl start hotel-app
          
          # Subir archivos de muestra al S3 (imágenes de habitaciones)
          aws s3 cp /opt/hotel-app/static/rooms/ s3://${BucketName}/statics/rooms/ --recursive

Outputs:
  WebServerPublicIP:
    Description: 'Public IP address of the web server'
    Value: !GetAtt WebServerInstance.PublicIp
    
  DynamoDBTableName:
    Description: 'Name of the DynamoDB table'
    Value: !Ref HotelReservationsTable
    
  S3BucketName:
    Description: 'Name of the S3 bucket'
    Value: !Ref HotelReservationsBucket
    
  LambdaFunctionName:
    Description: 'Name of the Lambda function'
    Value: !Ref ReservationValidatorFunction